## **Application Layer**

### **Purpose**
The Application layer handles:
- **Use Cases**: Orchestrates workflows and calls domain logic.
- **DTOs**: Defines input/output models.
- **Validation**: Validates inputs and outputs for use cases.

---

### **Components**

#### **Use Cases**
Example of a use case:
```csharp
public class CancelOrderUseCase
{
    private readonly IOrderRepository _orderRepository;

    public CancelOrderUseCase(IOrderRepository orderRepository)
    {
        _orderRepository = orderRepository;
    }

    public void Execute(Guid orderId)
    {
        var order = _orderRepository.GetById(orderId);
        if (order == null)
            throw new KeyNotFoundException("Order not found.");

        order.Cancel();
        _orderRepository.Save(order);
    }
}
```
#### **DTOs**
- DTOs transform data between layers. Example:
```
public class OrderDto
{
    public Guid Id { get; set; }
    public string Status { get; set; }
}
```
- Don't let DTOs know about the Domain. DTOs speak to DTOs.
- The purpose of a DTO is to limit underposting, overposting or providing too much information to the user.
  - DTOs for presenting summary data in a list would be leaner than DTOs for looking at things in more detail. e.g (OrderListDTO, OrderDetailDTO) but both may map from the Order entity. 

#### **Service Collection Extentions**
- We want to be able to have all our injectable components defined at the application level but any client application can just call this method and have it registered inside itself.


#### **Validation**
- Use FluentValidation or similar libraries for input validation.

#### **Repository Pattern**
-  `public interface IGenericRepository<T> where T : class` 
-  Methods like Get, GetAll, Add, Update, Delete
-  We may extent our `IGenericRepostiry` with Repositories for our entities. e.g `IOrderRepository.cs` 

#### **Making BaseDomainEntities**
  - An entity class for all entites to share. (i.e fields: Id, DateCreated, LastModifiedDate etc.)

#### **AutoMapper**
  - Convert from one data type to another
  - Usually used here in conjuction with Mediator acting as messageing between what is coming from the client and what is going to the database.
  - Generally speaking bad practise to interact directly with the domain objects/ entities.
  - We create abstractions (DTOs). Classes that look like domain objects but have restrictions on operations.
  - Setup within the Application project.
  - When setting up in DI instead of doing
    ```
        services.AddAutoMapper(typeof(MappingProfile1));
        services.AddAutoMapper(typeof(MappingProfile2));
        services.AddAutoMapper(typeof(MappingProfile3));
    
    //DO THIS INSTEAD
        services.AddAutoMapper(Assembly.GetExecutingAssembly()); //This will traverse every mappingprofile that inherits from Automapper.Profile

    ```

### Best Practices
- Avoid complex logic in this layer; delegate it to the Core layer.
- Depend only on abstractions (e.g., interfaces).