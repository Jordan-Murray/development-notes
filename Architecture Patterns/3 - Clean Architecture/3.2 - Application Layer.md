## **Application Layer**

### **Purpose**
The Application layer handles:
- **Use Cases**: Orchestrates workflows and calls domain logic.
- **DTOs**: Defines input/output models.
- **Validation**: Validates inputs and outputs for use cases.

---

### **Components**

#### **Use Cases**
Example of a use case:
```csharp
public class CancelOrderUseCase
{
    private readonly IOrderRepository _orderRepository;

    public CancelOrderUseCase(IOrderRepository orderRepository)
    {
        _orderRepository = orderRepository;
    }

    public void Execute(Guid orderId)
    {
        var order = _orderRepository.GetById(orderId);
        if (order == null)
            throw new KeyNotFoundException("Order not found.");

        order.Cancel();
        _orderRepository.Save(order);
    }
}
```
#### **DTOs**
- DTOs transform data between layers. Example:
```
public class OrderDto
{
    public Guid Id { get; set; }
    public string Status { get; set; }
}
```

#### **Validation**
- Use FluentValidation or similar libraries for input validation.

#### **Repository Pattern**
-  `public interface IGenericRepository<T> where T : class` 
-  Methods like Get, GetAll, Add, Update, Delete
-  We may extent our `IGenericRepostiry` with Repositories for our entities. e.g `IOrderRepository.cs` 

#### **Making BaseDomainEntities**
  - An entity class for all entites to share. (i.e fields: Id, DateCreated, LastModifiedDate etc.)

#### **AutoMapper**
  - Convert from one data type to another
  - Usually used here in conjuction with Mediator acting as messageing between what is coming from the client and what is going to the database.
  - Generally speaking bad practise to interact directly with the domain objects/ entities.
  - We create abstractions (DTOs). Classes that look like domain objects but have restrictions on operations.
  - Setup within the Application project.

### Best Practices
- Avoid complex logic in this layer; delegate it to the Core layer.
- Depend only on abstractions (e.g., interfaces).